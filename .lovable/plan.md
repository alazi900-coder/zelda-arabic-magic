
الذي تقترحه الآن واضح جداً، وبعد فحص الكود الحالي السبب الجذري عندك غالباً ليس نفس فكرة Manus (تقسيم حسب عدد أحرف)، بل مشكلة حفظ الأسطر نفسها داخل المحرر.

## التشخيص الحقيقي (من الكود الحالي)

1) **حقل الترجمة نفسه أحادي السطر**
- الملف: `src/components/editor/DebouncedInput.tsx`
- حالياً يستخدم:
  - `<input type="text">`
- هذا النوع **لا يحافظ على فواصل الأسطر** (`\n`) بشكل آمن.
- النتيجة: إذا عدّلت أي ترجمة كانت متعددة الأسطر، يمكن أن تتحول لسطر واحد (أو تتسطّح)، ثم عند البناء تظهر داخل اللعبة بخط أصغر ومضغوط.

2) **تفسير سلوكك الذي ذكرته**
- “كانت 3 أسطر ثم غيّرت كلمة وصارت سطر واحد صغير، ثم رجّعت الكلمة السابقة وبقيت صغيرة”
- هذا متوافق 100% مع فقدان `\n`:
  - أنت قد ترجع الكلمات نفسها، لكن **فواصل الأسطر الأصلية لم تعد موجودة**.

3) **ملاحظة إضافية مهمة في الترجمة الجماعية**
- الملف: `supabase/functions/translate-entries/index.ts`
- مزود Google في وضع batch يجمع النصوص بـ `join('\n')` ثم يفصلها بـ `split('\n')`.
- هذا تصميم هش إذا كان النص نفسه يحتوي فواصل أسطر أصلية، وقد يسبب التباس حدود النصوص.
- حتى لو أصلحنا الإدخال، هذا يحتاج تحصين لمنع مشاكل مستقبلية.

---

## القرار بخصوص اقتراح Manus
- **لا أنصح** بالاعتماد على تقسيم ثابت بعدد الأحرف كحل رئيسي؛ لأنه قد يقسم الجملة في أماكن غير طبيعية.
- الأفضل:
  1) نحافظ على فواصل الأسطر الأصلية أولاً (حل جذري).
  2) نضيف fallback ذكي فقط عند الحاجة للنصوص القديمة المتضررة.

---

## خطة التنفيذ المقترحة

### المرحلة 1 — إصلاح الجذر في واجهة التحرير (الأولوية القصوى)
**الملفات:**
- `src/components/editor/DebouncedInput.tsx`
- `src/components/editor/EntryCard.tsx`
- `src/components/editor/QuickReviewMode.tsx`
- `src/pages/Editor.tsx` (لأن DebouncedInput مستخدم أيضاً في البحث)

**ما سيتم:**
- جعل `DebouncedInput` يدعم وضعين:
  - `singleLine` (للبحث)
  - `multiline` (للترجمة) باستخدام `<textarea>`
- تمرير `multiline` في حقول الترجمة فقط.
- الحفاظ على debounce + blur flush بنفس السلوك الحالي.
- ضبط `dir` و`unicode-bidi` في حقل الترجمة لسلامة عرض العربية + الوسوم.

**النتيجة:**
- أي ترجمة متعددة الأسطر ستبقى متعددة الأسطر عند التعديل.

---

### المرحلة 2 — تحصين خط الترجمة الجماعية ضد ضياع `\n`
**الملف:**
- `supabase/functions/translate-entries/index.ts`

**ما سيتم:**
- قبل الإرسال في Google batch:
  - حماية `\n` داخل كل نص بـ placeholders مستقلة (مثل `NL_0_0`).
- بعد الاسترجاع:
  - إعادة placeholders إلى `\n` داخل نفس النص.
- تعديل prompt/تنظيف المخرجات لضمان عدم كسر placeholders.

**النتيجة:**
- الترجمة بالذكاء الاصطناعي لن تكسر تقسيم الأسطر الأصلي.

---

### المرحلة 3 — أداة استرجاع للنصوص التي تضررت سابقاً (اختياري لكن مفيد)
**الملفات المحتملة:**
- `src/hooks/useEditorState.ts`
- Panel تنظيف/مراجعة قائم (بنمط مراجعة “قبول/رفض”)

**ما سيتم:**
- فحص الحالات:
  - الأصل يحتوي عدة أسطر
  - الترجمة تحتوي سطر واحد
- اقتراح split مرن على حدود الكلمات بعدد أسطر الأصل.
- واجهة مراجعة “قبل/بعد” مع قبول أو رفض لكل سطر.

**النتيجة:**
- إصلاح سريع للبيانات التي انضغطت سابقاً بدون إعادة ترجمة كاملة.

---

## التحقق بعد التنفيذ

1) اختبار يدوي داخل المحرر:
- فتح ترجمة متعددة الأسطر.
- تعديل كلمة فقط.
- التأكد أن `\n` لم تختف.

2) اختبار ترجمة صفحة + جميع الصفحات:
- نصوص تحتوي أسطر متعددة.
- التأكد أن نتيجة المقارنة تحتفظ بعدد الأسطر.

3) بناء وتجربة داخل Citron:
- مقارنة نفس النص قبل/بعد.
- التأكد أن النص يعود بالحجم الطبيعي غير المضغوط.

4) اختبار عدم كسر البحث:
- `DebouncedInput` في شريط البحث يبقى أحادي السطر كالمعتاد.

---

## مخرجات متوقعة للمستخدم بعد الإصلاح

- لن يتكرر سيناريو “أعدت نفس الجملة لكن بقيت سطر واحد صغير”.
- ستحصل على سلوك مطابق لتوقعك: الترجمة تحافظ على بنية الأسطر، مع مراجعة واضحة قبل التطبيق.
- يمكن معالجة النصوص التي تضررت مسبقاً عبر أداة مراجعة بدل إعادة العمل يدوياً من الصفر.
