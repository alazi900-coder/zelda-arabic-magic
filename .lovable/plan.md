
الطلب مفهوم تمامًا، والمشكلة حقيقية فعلًا: النظام الحالي يسمح أحيانًا بتحويل `1[ML]` إلى صيغة مثل `[ML:icon icon=btn_a ]` بدل الحفاظ على نفس الرمز الأصلي، وهذا يكسر عرض الأزرار داخل اللعبة.

سبب الخلل (بعد مراجعة الكود الحالي):
1) في `supabase/functions/translate-entries/index.ts`  
   دالة الحماية `protectTags` على السيرفر لا تغطي كل الصيغ المدعومة في الواجهة (خصوصًا `1[ML]` و `[ML]1` و `[TAG=Value]` و `{TAG:Value}`)، لذلك بعض مسارات الترجمة (خصوصًا الدُفعات) ترسل رموزًا غير محمية للذكاء الاصطناعي.

2) في `src/components/editor/types.tsx`  
   `hasTechnicalTags` ضيقة جدًا (تتعرف أساسًا على رموز التحكم و`[Tag:...]`) ولا تعتبر `1[ML]`/`[ML]1` كرموز تقنية، فيتخطى النظام بعض خطوات الإصلاح والتحقق.

3) في `src/lib/xc3-tag-restoration.ts`  
   `restoreTagsLocally` مبنية عمليًا على مستوى الحرف، فتنجح مع PUA/control chars لكن لا تستعيد الوسوم متعددة الحروف (مثل `1[ML]`) بشكل موثوق.

4) في `src/hooks/useEditorState.ts` (فحص أقواس الرموز)  
   حالة التحذير الحالية تلتقط بعض الأنماط الخاطئة، لكن لا تلتقط جيدًا حالات مثل ظهور `[ML:icon ...]` بدل `1[ML]`؛ لذلك قد تظهر رسالة “الرموز صحيحة” وهي ليست كذلك.

ما سيتم تنفيذه لحل فعّال وثابت:

1) توحيد “تعريف الرمز التقني” في مصدر واحد
- إنشاء/توسيع مجموعة regex موحدة تشمل:
  - `[Tag:Value]`
  - `[TAG]N`
  - `N[TAG]`
  - `[TAG=Value]`
  - `{TAG:Value}`
  - PUA/control chars
- ثم استخدام هذا التعريف في:
  - `hasTechnicalTags`
  - `restoreTagsLocally`
  - فحوص الجودة والمراجعة
  - فحوص قبل البناء
الهدف: لا يبقى أي مسار يعتبر `1[ML]` “نص عادي”.

2) تقوية حماية الترجمة على السيرفر (الأولوية القصوى)
- تحديث `protectTags` داخل `supabase/functions/translate-entries/index.ts` لتطابق نفس الصيغ المدعومة في الواجهة.
- التأكد أن كل مزود ترجمة (AI / Google / MyMemory) يمر دائمًا عبر نفس آلية الحماية/الاسترجاع.
- إبقاء طبقة `normalizeTagPlaceholders` ثم التحقق النهائي من وجود كل placeholders قبل الاسترجاع.
النتيجة: الذكاء الاصطناعي لن يرى `1[ML]` أصلًا، بل `TAG_N`، وبالتالي لن يستطيع تحويلها إلى `[ML:icon ...]`.

3) إصلاح الاسترجاع المحلي ليعالج الوسوم المركبة فعليًا
- إعادة تصميم `restoreTagsLocally` ليعمل على “tokens” بدل فحص حرف-بحرف.
- عند وجود وسم مفقود من الأصل (مثل `1[ML]`) يتم استرجاعه من النص الأصلي بطريقة آمنة.
- إضافة منطق يمنع التضارب عند وجود وسوم AI مخترعة لا تطابق الأصل.
النتيجة: لو فشل AI في سطر ما، ما زال عندنا fallback حقيقي يعيد الوسوم الصحيحة.

4) جعل كاشف الأخطاء يرفض الإيجابيات الكاذبة
- تحسين `handleScanTagBrackets` في `src/hooks/useEditorState.ts`:
  - يعتبر الحالة “غير صحيحة” إذا كان الأصل يحتوي وسومًا محددة والنتيجة لا تحتويها حرفيًا.
  - يرصد “وسوم دخيلة” (مثل `[ML:icon ...]`) عندما لا تكون موجودة في الأصل.
- تعديل رسالة النجاح بحيث لا تظهر إلا إذا تحقق التطابق البنيوي الكامل للوسوم التقنية.

5) تغطية كل مسارات الترجمة في الواجهة بنفس سلوك الحماية
- مراجعة مسارات:
  - ترجمة مفردة
  - ترجمة صفحة
  - ترجمة كل الصفحات
  - الترجمة التلقائية/إعادة الترجمة
  - مقارنة المحركات
- ضمان المرور بنفس pipeline: حماية -> ترجمة -> استرجاع -> تحقق سلامة -> إصلاح آمن.
الهدف: لا يعود فيه “مسار سليم” و”مسار يخرّب الوسوم”.

6) اختبارات Regression مباشرة على حالتك
- تحديث/إضافة اختبارات في:
  - `src/test/xc3-protection.test.ts`
  - `src/test/tag-bracket-fix.test.ts`
  - (وإن لزم) اختبار مخصص للاسترجاع المحلي
- حالات إلزامية:
  - الأصل: `Press 1[ML] ... hold 2[ML] ...`
  - التأكد أن الخرج النهائي يحتفظ بـ `1[ML]` و`2[ML]` حرفيًا
  - رفض/كشف حالة `[ML:icon icon=btn_a ]` إذا لم تكن في الأصل
  - عدم حذف أقواس أو وسوم سليمة أثناء الإصلاح

الملفات المستهدفة:
- `supabase/functions/translate-entries/index.ts`
- `src/components/editor/types.tsx`
- `src/lib/xc3-tag-restoration.ts`
- `src/hooks/useEditorState.ts`
- `src/hooks/useEditorTranslation.ts` (مراجعة التوافق بين المسارات)
- `src/components/editor/CompareEnginesDialog.tsx` (إن احتاج توحيد pipeline)
- `src/test/xc3-protection.test.ts`
- `src/test/tag-bracket-fix.test.ts`

معيار النجاح بعد التنفيذ:
- عند وجود `1[ML]` في الإنجليزي، تبقى `1[ML]` في الترجمة النهائية (لا تتحول لصيغة أخرى).
- لا تظهر رسالة “جميع الرموز صحيحة” إذا كان هناك فقد/استبدال للوسم.
- نفس السلوك في كل أوضاع الترجمة، وليس فقط بعض الأزرار.
- عدم حدوث إصلاحات مدمّرة أو حذف عشوائي للأقواس.

ملاحظة تنفيذية مهمة:
لن أعتمد على “إصلاح بعد الخطأ” فقط؛ سأقفل المشكلة من المصدر (الحماية قبل الإرسال + تحقق صارم بعد الاسترجاع + fallback محلي قوي) حتى لا يتكرر فساد الوسوم مستقبلًا حتى مع اختلاف نماذج الذكاء الاصطناعي.
