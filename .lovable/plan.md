
السبب واضح من الكود الحالي: يوجد أكثر من نسخة مختلفة لمنطق إصلاح الأقواس، وبعض المسارات لا تستخدم الإصلاح أصلًا بعد الترجمة. هذا يؤدي إلى سلوك متضارب: أحيانًا يتم إصلاح، وأحيانًا يتم حذف أقواس بدون استرجاع الرمز التقني الصحيح.

## التشخيص الدقيق (من الملفات الحالية)

1) `src/hooks/useEditorTranslation.ts`
- يوجد `autoFixTagBrackets` لكن:
  - لا يتم استدعاؤه في `handleTranslateSingle`.
  - لا يتم استدعاؤه في `handleTranslatePage` (مسار ترجمة صفحة كلمة بكلمة).
- يتم استخدام `autoFixTags` فقط في بعض المسارات (مثل auto/retranslate/damaged), وليس كل المسارات.

2) `src/hooks/useEditorState.ts`
- `handleScanTagBrackets` يحتوي نسخة inline مختلفة وأقدم من منطق الإصلاح.
- هذه النسخة تزيل الأقواس اليتيمة بشكل عدواني، لكنها لا تملك كل حالات الإصلاح الجديدة (مثل bare inner وغيرها)، فتحدث نتيجة: حذف قوس بدون استرجاع رمز صحيح.

3) `src/components/editor/TagBracketFixPanel.tsx`
- يحتوي أيضًا نسخة ثالثة من نفس المنطق (`fixTagBrackets`)؛ أي تكرار في 3 أماكن، وهذا سبب مباشر لتضارب النتائج.

## الخطة التنفيذية لحل المشكلة نهائيًا

### 1) توحيد منطق إصلاح الأقواس في مكان واحد فقط
إنشاء/نقل منطق الإصلاح إلى utility موحد (مثلًا `src/lib/tag-bracket-fix.ts`) ويصدر دوال واضحة:

- `fixTagBracketsStrict(original, translation): { text, stats }`
- `hasTechnicalBracketTag(original): boolean`

الفكرة: أي فحص أو إصلاح أو إصلاح تلقائي يستخدم نفس الدالة بالضبط، بدون نسخ.

### 2) جعل الإصلاح “آمن” (لا حذف بدون تعويض)
تعديل الخوارزمية بحيث:
- لا يتم حذف أي `[` أو `]` إلا إذا تحققنا أننا استعدنا/ثبتنا الوسم التقني المقابل.
- إذا كان النص غير قابل للإصلاح بثقة، نتركه كما هو (fail-safe) بدل حذف الأقواس.
- دعم الحالات التالية بشكل متسق:
  - `]TAG[`
  - `]TAG]` و `[TAG[`
  - `TAG` بدون أقواس وسط نص عربي
  - انعكاس RTL/BiDi
  - اختلافات طفيفة في المسافات داخل الوسم

### 3) تطبيق الإصلاح التلقائي على كل مسارات الترجمة بالذكاء الاصطناعي
في `useEditorTranslation.ts`:
- بعد كل ترجمة فردية في `handleTranslateSingle`:
  - `restoreTags(...)` ثم `restoreTagsLocally(...)` ثم `fixTagBracketsStrict(...)`.
- داخل `handleTranslatePage` (كلمة بكلمة):
  - نفس السلسلة لكل عنصر قبل إدخاله في `allTranslations`.
- الإبقاء على نفس السلسلة في auto/retranslate/fixDamaged لتوحيد كامل.

النتيجة: “بعد كل ترجمة AI” فعليًا سيتم الإصلاح، وليس في بعض المسارات فقط.

### 4) توحيد أداة المراجعة مع نفس المنطق
في `useEditorState.ts`:
- حذف الـ inline fixer داخل `handleScanTagBrackets`.
- استدعاء utility الموحد فقط.

في `TagBracketFixPanel.tsx`:
- تحويله إلى واجهة عرض فقط (UI).
- إزالة منطق الإصلاح منه (أو جعله يستورد نفس utility بدل نسخة داخلية).

النتيجة: ما تراه في لوحة “قبل/بعد” يطابق 100% ما سيطبّق تلقائيًا في الترجمة.

### 5) إضافة اختبارات تغطي المشكلة التي ظهرت لك
إضافة ملف اختبار جديد (مثل `src/test/tag-bracket-fix.test.ts`) يتضمن حالات واقعية:
- عدم حذف الأقواس عند وجود وسم تقني.
- إصلاح `]ML:...[` إلى `[ML:...]`.
- إصلاح وسم بدون أقواس داخل نص عربي.
- عدم تنفيذ “orphan cleanup” بشكل مدمر.
- نفس الإدخال يعطي نفس النتيجة في:
  - auto-fix بعد الترجمة
  - scan tool (لوحة الإصلاح)

## الملفات المستهدفة

- `src/hooks/useEditorTranslation.ts`
- `src/hooks/useEditorState.ts`
- `src/components/editor/TagBracketFixPanel.tsx`
- `src/lib/tag-bracket-fix.ts` (جديد)
- `src/test/tag-bracket-fix.test.ts` (جديد)

## ترتيب التنفيذ

1. بناء utility الموحد الآمن.
2. ربطه بكل مسارات الترجمة في `useEditorTranslation`.
3. ربطه بأداة الفحص في `useEditorState`.
4. تنظيف `TagBracketFixPanel` ليصبح عرض فقط.
5. إضافة الاختبارات.
6. مراجعة سريعة للتأكد أن كل الاستدعاءات تستخدم نفس الدالة (لا نسخ منطق).

## النتيجة المتوقعة بعد التنفيذ

- لن يتم حذف الأقواس التقنية بشكل خاطئ.
- الإصلاح التلقائي سيعمل بعد كل ترجمة AI بالفعل.
- أداة “إصلاح أقواس الرموز التقنية” ستعرض نفس المنطق الحقيقي المستخدم في النظام.
- تقليل كبير جدًا في تلف الوسوم التقنية داخل النص العربي.

## ملاحظة تقنية مهمة
حتى لا يتكرر الخطأ مستقبلًا، سأمنع تكرار منطق الإصلاح في ملفات متعددة، وأجعل هناك مصدر واحد للحقيقة (single source of truth) مع اختبارات مباشرة على الحالات التي أرسلتها.
