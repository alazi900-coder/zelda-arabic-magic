import "jsr:@supabase/functions-js/edge-runtime.d.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// --- Tag Protection: replace technical tags + abbreviations with TAG_N placeholders ---
const PROTECTED_ABBREVIATIONS = [
  'EXP', 'PST', 'CP', 'SP', 'HP', 'AP', 'TP', 'WP', 'DP',
  'ATK', 'DEF', 'AGI', 'DEX', 'LUK', 'CRI', 'BLK',
  'DPS', 'DOT', 'AOE', 'HoT', 'MPH',
  'Lv', 'LV', 'MAX', 'DLC', 'NPC', 'QTE', 'UI', 'HUD',
  'KO', 'NG', 'NG\\+',
  'm', 's', 'x', 'g', 'kg', 'km', 'cm', 'mm',
];
const ABBREV_PATTERN = new RegExp(`\\b(${PROTECTED_ABBREVIATIONS.join('|')})\\b`, 'g');

function protectTags(text: string): { cleaned: string; tags: Map<string, string> } {
  const tags = new Map<string, string>();
  let counter = 0;
  const patterns: RegExp[] = [
    /[\uE000-\uE0FF]+/g,
    /\[\w+:[^\]]*?\s*\](?:\s*\([^)]{1,100}\))?/g,
    /\{[\w]+\}/g,
    /[\uFFF9-\uFFFC]/g,
    /<[\w\/][^>]*>/g,
    /\([A-Z][^)]{1,100}\)/g,
    ABBREV_PATTERN,
  ];

  // Collect all matches
  const matches: { start: number; end: number; original: string }[] = [];
  for (const pattern of patterns) {
    const regex = new RegExp(pattern.source, pattern.flags);
    let match: RegExpExecArray | null;
    while ((match = regex.exec(text)) !== null) {
      const start = match.index;
      const end = start + match[0].length;
      const overlaps = matches.some(m => start < m.end && end > m.start);
      if (!overlaps) {
        matches.push({ start, end, original: match[0] });
      }
    }
  }
  matches.sort((a, b) => a.start - b.start);

  if (matches.length === 0) return { cleaned: text, tags };

  let cleaned = '';
  let lastEnd = 0;
  for (const m of matches) {
    cleaned += text.slice(lastEnd, m.start);
    const placeholder = `TAG_${counter}`;
    tags.set(placeholder, m.original);
    cleaned += placeholder;
    counter++;
    lastEnd = m.end;
  }
  cleaned += text.slice(lastEnd);

  return { cleaned, tags };
}

/** Normalize malformed TAG_N variants that AI engines may produce */
function normalizeTagPlaceholders(text: string): string {
  return text
    .replace(/TAG\s+_?(\d+)/gi, 'TAG_$1')           // "TAG 0", "TAG _0" → "TAG_0"
    .replace(/(?<!\w)TAG(\d+)(?!\w)/gi, 'TAG_$1')    // "TAG0" → "TAG_0"
    .replace(/tag_(\d+)/g, 'TAG_$1')                  // "tag_0" → "TAG_0"
    .replace(/[《〈«⟪\[(<]\s*T(?:AG)?[_\s]?(\d+)\s*[》〉»⟫\])>]/gi, 'TAG_$1');  // «T0» etc → TAG_0
}

function restoreTags(text: string, tags: Map<string, string>): string {
  let result = text;
  for (const [placeholder, original] of tags) {
    result = result.replace(placeholder, original);
  }
  return result;
}

// --- Term Locking System ---
// Replaces glossary terms in source text with locked placeholders before AI translation,
// then swaps them back to the approved Arabic translations afterward.

interface TermLockResult {
  lockedText: string;
  locks: { placeholder: string; english: string; arabic: string }[];
}

function lockTermsInText(text: string, glossaryMap: Map<string, string>): TermLockResult {
  if (glossaryMap.size === 0) return { lockedText: text, locks: [] };

  const textLower = text.toLowerCase();

  // Pre-filter: only keep terms that actually appear in the text (fast string check)
  const candidateTerms: [string, string][] = [];
  for (const [eng, arab] of glossaryMap) {
    if (eng.length < 2) continue;
    if (textLower.includes(eng)) {
      candidateTerms.push([eng, arab]);
    }
  }

  if (candidateTerms.length === 0) return { lockedText: text, locks: [] };

  // Sort by length (longest first) to prevent partial matches
  candidateTerms.sort((a, b) => b[0].length - a[0].length);

  const locks: TermLockResult['locks'] = [];
  let lockedText = text;
  let lockCounter = 0;

  for (const [eng, arab] of candidateTerms) {
    const escaped = eng.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const pattern = eng.length <= 3
      ? new RegExp(`\\b${escaped}\\b`, 'gi')
      : new RegExp(`(?<![\\w-])${escaped}(?![\\w-])`, 'gi');

    const regex = new RegExp(pattern.source, pattern.flags);
    let match: RegExpExecArray | null;
    
    while ((match = regex.exec(lockedText)) !== null) {
      const matchEnd = match.index + match[0].length;
      const surroundingSlice = lockedText.slice(match.index, matchEnd);
      if (surroundingSlice.includes('⟪') || surroundingSlice.includes('⟫')) continue;

      const placeholder = `⟪T${lockCounter}⟫`;
      lockedText = lockedText.slice(0, match.index) + placeholder + lockedText.slice(matchEnd);
      locks.push({ placeholder, english: match[0], arabic: arab });
      lockCounter++;
      regex.lastIndex = match.index + placeholder.length;
    }
  }

  return { lockedText, locks };
}

function normalizeTermBrackets(text: string): string {
  return text
    .replace(/[《〈«]/g, '⟪')
    .replace(/[》〉»]/g, '⟫');
}

function unlockTerms(translatedText: string, locks: TermLockResult['locks']): string {
  // Normalize AI-corrupted bracket variants before matching
  let result = normalizeTermBrackets(translatedText);
  for (const lock of locks) {
    result = result.replace(lock.placeholder, lock.arabic);
  }
  // Fallback: catch any remaining bracket variants the AI may have introduced
  result = result.replace(/[⟪《〈«]T(\d+)[⟫》〉»]/g, (_match, num) => {
    const lock = locks.find(l => l.placeholder === `⟪T${num}⟫`);
    return lock ? lock.arabic : _match;
  });
  return result;
}

// --- Apply glossary replacements to translated text (post-processing) ---
function applyGlossaryPost(text: string, glossaryMap: Map<string, string>): string {
  let result = text;
  const textLower = text.toLowerCase();
  for (const [eng, ara] of glossaryMap) {
    if (eng.length < 2) continue;
    if (!textLower.includes(eng)) continue; // Fast pre-filter
    const escaped = eng.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`\\b${escaped}\\b`, 'gi');
    result = result.replace(regex, ara);
  }
  return result;
}

// --- Fetch with retry ---
async function fetchWithRetry(url: string, retries = 2, delayMs = 1000): Promise<Response> {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const response = await fetch(url);
      if (response.ok || response.status === 400) return response;
      if (attempt < retries) {
        await new Promise(r => setTimeout(r, delayMs * (attempt + 1)));
      } else {
        return response;
      }
    } catch (err) {
      if (attempt >= retries) throw err;
      await new Promise(r => setTimeout(r, delayMs * (attempt + 1)));
    }
  }
  throw new Error('fetchWithRetry exhausted');
}

// --- Pick best translation from MyMemory matches ---
function pickBestTranslation(data: any): string | null {
  const primary = data?.responseData?.translatedText;
  const primaryMatch = data?.responseData?.match;
  
  const matches = data?.matches;
  if (Array.isArray(matches) && matches.length > 0) {
    const ranked = matches
      .filter((m: any) => m.translation?.trim() && m.segment?.trim())
      .sort((a: any, b: any) => {
        const aHuman = a['created-by'] !== 'MT' ? 1 : 0;
        const bHuman = b['created-by'] !== 'MT' ? 1 : 0;
        if (aHuman !== bHuman) return bHuman - aHuman;
        return (b.match || 0) - (a.match || 0);
      });
    
    if (ranked.length > 0 && ranked[0].match >= 0.5) {
      return ranked[0].translation;
    }
  }
  
  if (primary?.trim() && primaryMatch >= 0.3) {
    return primary;
  }
  
  return primary?.trim() ? primary : null;
}

// --- MyMemory free translation ---
async function translateWithMyMemory(
  entries: { key: string; original: string }[],
  protectedEntries: { key: string; cleaned: string; tags: Map<string, string> }[],
  glossaryMap?: Map<string, string>,
  email?: string,
): Promise<{ translations: Record<string, string>; charsUsed: number; glossaryStats: GlossaryStats }> {
  const result: Record<string, string> = {};
  let charsUsed = 0;
  const stats: GlossaryStats = { directMatches: 0, lockedTerms: 0, contextTerms: 0 };

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const pe = protectedEntries[i];
    const textToTranslate = pe.cleaned.trim();
    
    if (!textToTranslate) continue;

    // Check glossary for exact match first
    if (glossaryMap) {
      const norm = textToTranslate.toLowerCase();
      const hit = glossaryMap.get(norm);
      if (hit) {
        result[entry.key] = restoreTags(hit, pe.tags);
        stats.directMatches++;
        continue;
      }
    }

    // Term locking before translation
    let textForTranslation = textToTranslate;
    let termLocks: TermLockResult = { lockedText: textToTranslate, locks: [] };
    if (glossaryMap && glossaryMap.size > 0) {
      termLocks = lockTermsInText(textToTranslate, glossaryMap);
      textForTranslation = termLocks.lockedText;
      stats.lockedTerms += termLocks.locks.length;
    }

    try {
      let url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textForTranslation)}&langpair=en|ar`;
      if (email?.trim()) {
        url += `&de=${encodeURIComponent(email.trim())}`;
      }
      
      const response = await fetchWithRetry(url);
      if (!response.ok) {
        console.error(`MyMemory error for key ${entry.key}: ${response.status}`);
        await response.text();
        continue;
      }
      const data = await response.json();
      
      let translation = pickBestTranslation(data);
      
      if (translation?.trim()) {
        translation = normalizeTagPlaceholders(translation);
        // Unlock terms first (replace placeholders with Arabic)
        if (termLocks.locks.length > 0) {
          translation = unlockTerms(translation, termLocks.locks);
        }
        // Then apply glossary post-processing for any remaining English terms
        if (glossaryMap) {
          translation = applyGlossaryPost(translation, glossaryMap);
        }
        result[entry.key] = restoreTags(translation, pe.tags);
        charsUsed += textToTranslate.length;
      }
    } catch (err) {
      console.error(`MyMemory fetch error for key ${entry.key}:`, err);
    }
    
    if (i < entries.length - 1) {
      await new Promise(r => setTimeout(r, 150));
    }
  }

  return { translations: result, charsUsed, glossaryStats: stats };
}

// --- Google Translate ---
async function translateWithGoogle(
  entries: { key: string; original: string }[],
  protectedEntries: { key: string; cleaned: string; tags: Map<string, string> }[],
  glossaryMap?: Map<string, string>,
): Promise<{ translations: Record<string, string>; charsUsed: number; glossaryStats: GlossaryStats }> {
  const result: Record<string, string> = {};
  let charsUsed = 0;
  const stats: GlossaryStats = { directMatches: 0, lockedTerms: 0, contextTerms: 0 };

  const useIndividual = entries.length <= 5;

  if (useIndividual) {
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const pe = protectedEntries[i];
      const text = pe.cleaned.trim();
      if (!text) continue;

      if (glossaryMap) {
        const norm = text.toLowerCase();
        const hit = glossaryMap.get(norm);
        if (hit) {
          result[entry.key] = restoreTags(hit, pe.tags);
          stats.directMatches++;
          continue;
        }
      }

      // Term locking
      let textForTranslation = text;
      let termLocks: TermLockResult = { lockedText: text, locks: [] };
      if (glossaryMap && glossaryMap.size > 0) {
        termLocks = lockTermsInText(text, glossaryMap);
        textForTranslation = termLocks.lockedText;
        stats.lockedTerms += termLocks.locks.length;
      }

      try {
        const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=ar&dt=t&q=${encodeURIComponent(textForTranslation)}`;
        const response = await fetchWithRetry(url);
        if (!response.ok) {
          console.error(`Google Translate error for key ${entry.key}: ${response.status}`);
          await response.text();
          continue;
        }
        const data = await response.json();

        let translation = '';
        if (Array.isArray(data) && Array.isArray(data[0])) {
          for (const segment of data[0]) {
            if (Array.isArray(segment) && segment[0]) {
              translation += segment[0];
            }
          }
        }
        translation = translation.trim();

        if (translation) {
          translation = normalizeTagPlaceholders(translation);
          if (termLocks.locks.length > 0) {
            translation = unlockTerms(translation, termLocks.locks);
          }
          if (glossaryMap) {
            translation = applyGlossaryPost(translation, glossaryMap);
          }
          result[entry.key] = restoreTags(translation, pe.tags);
          charsUsed += text.length;
        }
      } catch (err) {
        console.error(`Google Translate error for key ${entry.key}:`, err);
      }

      if (i < entries.length - 1) {
        await new Promise(r => setTimeout(r, 100));
      }
    }
  } else {
    // Batch mode
    const batchSize = 20;
    for (let start = 0; start < entries.length; start += batchSize) {
      const batchEntries = entries.slice(start, start + batchSize);
      const batchProtected = protectedEntries.slice(start, start + batchSize);

      const toTranslate: { idx: number; text: string; termLocks: TermLockResult }[] = [];
      for (let i = 0; i < batchEntries.length; i++) {
        const pe = batchProtected[i];
        const text = pe.cleaned.trim();
        if (!text) continue;
        if (glossaryMap) {
          const norm = text.toLowerCase();
          const hit = glossaryMap.get(norm);
          if (hit) {
            result[batchEntries[i].key] = restoreTags(hit, pe.tags);
            stats.directMatches++;
            continue;
          }
        }
        // Term locking per entry
        let termLocks: TermLockResult = { lockedText: text, locks: [] };
        if (glossaryMap && glossaryMap.size > 0) {
          termLocks = lockTermsInText(text, glossaryMap);
          stats.lockedTerms += termLocks.locks.length;
        }
        toTranslate.push({ idx: i, text: termLocks.lockedText, termLocks });
      }

      if (toTranslate.length === 0) continue;

      const joinedText = toTranslate.map(t => t.text).join('\n');

      try {
        const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=ar&dt=t&q=${encodeURIComponent(joinedText)}`;
        const response = await fetchWithRetry(url);
        if (!response.ok) {
          console.error(`Google Translate batch error: ${response.status}`);
          await response.text();
          continue;
        }
        const data = await response.json();

        let fullTranslation = '';
        if (Array.isArray(data) && Array.isArray(data[0])) {
          for (const segment of data[0]) {
            if (Array.isArray(segment) && segment[0]) {
              fullTranslation += segment[0];
            }
          }
        }

        const translations = fullTranslation.split('\n');

        for (let j = 0; j < Math.min(toTranslate.length, translations.length); j++) {
          const t = toTranslate[j];
          let translation = translations[j]?.trim();
          if (translation) {
            translation = normalizeTagPlaceholders(translation);
            if (t.termLocks.locks.length > 0) {
              translation = unlockTerms(translation, t.termLocks.locks);
            }
            if (glossaryMap) {
              translation = applyGlossaryPost(translation, glossaryMap);
            }
            result[batchEntries[t.idx].key] = restoreTags(translation, batchProtected[t.idx].tags);
            charsUsed += t.text.length;
          }
        }
      } catch (err) {
        console.error('Google Translate batch error:', err);
      }

      if (start + batchSize < entries.length) {
        await new Promise(r => setTimeout(r, 200));
      }
    }
  }

  return { translations: result, charsUsed, glossaryStats: stats };
}

// --- Parse glossary text into a map ---
function parseGlossaryToMap(glossary: string): Map<string, string> {
  const map = new Map<string, string>();
  if (!glossary?.trim()) return map;
  for (const line of glossary.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
    const eqIdx = trimmed.indexOf('=');
    if (eqIdx < 1) continue;
    const eng = trimmed.slice(0, eqIdx).trim().toLowerCase();
    const arb = trimmed.slice(eqIdx + 1).trim();
    if (eng && arb) map.set(eng, arb);
  }
  return map;
}

// --- Filter glossary to only terms relevant to the batch texts ---
function filterRelevantGlossary(glossary: string, texts: string[]): string {
  if (!glossary?.trim()) return '';
  const combinedText = texts.join(' ').toLowerCase();
  const relevantLines: string[] = [];
  for (const line of glossary.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
    const eqIdx = trimmed.indexOf('=');
    if (eqIdx < 1) continue;
    const eng = trimmed.slice(0, eqIdx).trim();
    if (eng.length <= 2) {
      const regex = new RegExp(`\\b${eng.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
      if (regex.test(combinedText)) relevantLines.push(trimmed);
    } else {
      if (combinedText.includes(eng.toLowerCase())) relevantLines.push(trimmed);
    }
  }
  return relevantLines.join('\n');
}

// --- Glossary usage statistics ---
interface GlossaryStats {
  directMatches: number;
  lockedTerms: number;
  contextTerms: number;
}

// --- Build translation memory map from context entries ---
function buildTranslationMemory(context: { key: string; original: string; translation?: string }[] | undefined): Map<string, string> {
  const tmMap = new Map<string, string>();
  if (!context) return tmMap;
  for (const c of context) {
    if (!c.translation?.trim() || !c.original?.trim()) continue;
    // Add full-text mapping (lowercased)
    tmMap.set(c.original.trim().toLowerCase(), c.translation.trim());
  }
  return tmMap;
}

// --- AI translation (Gemini / Lovable gateway) ---
async function translateWithAI(
  entries: { key: string; original: string }[],
  protectedEntries: { key: string; cleaned: string; tags: Map<string, string> }[],
  glossary: string | undefined,
  context: { key: string; original: string; translation?: string }[] | undefined,
  userApiKey: string | undefined,
): Promise<{ translations: Record<string, string>; glossaryStats: GlossaryStats }> {
  const glossaryMap = glossary ? parseGlossaryToMap(glossary) : new Map<string, string>();
  const tmMap = buildTranslationMemory(context);
  const stats: GlossaryStats = { directMatches: 0, lockedTerms: 0, contextTerms: 0 };

  // --- Step 1: Direct matches (exact full-string from glossary OR translation memory) ---
  const directResult: Record<string, string> = {};
  const needsAI: { entry: typeof entries[0]; pe: typeof protectedEntries[0]; termLocks: TermLockResult }[] = [];

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const pe = protectedEntries[i];
    const norm = pe.cleaned.trim().toLowerCase();

    // Priority 1: Glossary exact match
    const glossaryHit = glossaryMap.get(norm);
    if (glossaryHit) {
      directResult[entry.key] = restoreTags(glossaryHit, pe.tags);
      stats.directMatches++;
      continue;
    }

    // Priority 2: Translation memory exact match (previously translated identical text)
    const tmHit = tmMap.get(norm);
    if (tmHit) {
      directResult[entry.key] = restoreTags(tmHit, pe.tags);
      stats.directMatches++;
      continue;
    }

    // --- Step 2: Term locking for partial matches (glossary terms inside text) ---
    const termLocks = lockTermsInText(pe.cleaned, glossaryMap);
    stats.lockedTerms += termLocks.locks.length;
    needsAI.push({ entry, pe, termLocks });
  }

  if (needsAI.length === 0) {
    return { translations: directResult, glossaryStats: stats };
  }

  // --- Step 3: Build prompt with term-locked texts ---
  const textsBlock = needsAI.map((item, i) => `[${i}] ${item.termLocks.lockedText}`).join('\n');

  let glossarySection = '';
  if (glossary?.trim()) {
    const batchTexts = needsAI.map(item => item.pe.cleaned);
    const relevantGlossary = filterRelevantGlossary(glossary, batchTexts);
    if (relevantGlossary.trim()) {
      const termCount = relevantGlossary.split('\n').length;
      stats.contextTerms = termCount;
      console.log(`Glossary: ${stats.directMatches} direct, ${stats.lockedTerms} locked, ${termCount} context terms`);
      glossarySection = `\n\nMANDATORY GLOSSARY (${termCount} terms) — You MUST use these exact Arabic translations. Do NOT paraphrase, alter, or use synonyms for any glossary term:\n${relevantGlossary}\n`;
    }
  }

  // Enhanced context section: show previous translations as mandatory consistency reference
  let contextSection = '';
  if (context && context.length > 0) {
    const contextLines = context
      .filter(c => c.translation?.trim())
      .map(c => `"${c.original}" → "${c.translation}"`)
      .slice(0, 15)
      .join('\n');
    if (contextLines) {
      contextSection = `\n\nPREVIOUSLY TRANSLATED TEXTS (for mandatory consistency — if you encounter the same words/phrases, use the SAME Arabic translation):\n${contextLines}\n`;
    }
  }

  let categoryHint = '';
  const sampleKey = entries[0]?.key || '';
  if (/ActorMsg\/PouchContent/i.test(sampleKey)) categoryHint = 'هذه نصوص أسماء أسلحة وأدوات ومواد - استخدم صيغة مختصرة ومباشرة.';
  else if (/LayoutMsg/i.test(sampleKey)) categoryHint = 'هذه نصوص واجهة مستخدم وقوائم - استخدم صيغة مختصرة وواضحة.';
  else if (/EventFlowMsg/i.test(sampleKey)) categoryHint = 'هذه حوارات قصة ومهام - استخدم أسلوباً سردياً طبيعياً وممتعاً.';
  else if (/ChallengeMsg/i.test(sampleKey)) categoryHint = 'هذه نصوص مهام وتحديات - استخدم أسلوباً تحفيزياً واضحاً.';
  else if (/LocationMsg/i.test(sampleKey)) categoryHint = 'هذه أسماء مواقع وخرائط - حافظ على الأسماء العلم أو ترجمها بالطريقة الشائعة.';
  else if (/ActorMsg/i.test(sampleKey)) categoryHint = 'هذه أسماء شخصيات وأعداء - حافظ على الأسماء العلم الشهيرة كما هي.';

  const categorySection = categoryHint ? `\n\n${categoryHint}` : '';

  const prompt = `You are a professional game translator specializing in Xenoblade Chronicles 3 (ゼノブレイド3). Translate the following game texts from English to Arabic.

CRITICAL RULES:
1. Placeholders like ⟪T0⟫, ⟪T1⟫, etc. are LOCKED TERMS — copy them EXACTLY as-is into your translation. Do NOT translate, modify, or remove them.
2. NEVER remove, modify, merge, or reorder TAG_0, TAG_1, TAG_2 etc. placeholders. They MUST appear in your output EXACTLY as they appear in the input. If the input has TAG_0 and TAG_1, your output MUST also have TAG_0 and TAG_1. Missing even one TAG placeholder will corrupt the game data.
3. Keep the translation length close to the original to fit in-game text boxes.
4. If a glossary term appears, you MUST use its EXACT Arabic translation — no alternatives, no synonyms, no paraphrasing. This is NON-NEGOTIABLE.
5. CONSISTENCY IS MANDATORY: If a word or phrase was translated a certain way in the "Previously Translated Texts" section, you MUST translate it the same way. Never use different Arabic words for the same English term.
6. Use terminology consistent with the Arabic gaming community for Xenoblade Chronicles 3.
7. Preserve proper nouns (Noah, Mio, Eunie, Taion, Lanz, Sena, Aionios) as-is or use their established Arabic equivalents from the glossary.
8. Return ONLY a JSON array of strings in the same order. No explanations.${categorySection}${glossarySection}${contextSection}

Texts:
${textsBlock}`;

  const effectiveKey = userApiKey?.trim() || Deno.env.get('GEMINI_API_KEY') || '';
  
  const parseAndUnlock = (translations: string[]): Record<string, string> => {
    const result: Record<string, string> = {};
    for (let i = 0; i < Math.min(needsAI.length, translations.length); i++) {
      let translated = translations[i]?.trim();
      if (!translated) continue;
      const item = needsAI[i];

      // Safety check: reject suspiciously short translations (likely mismatched)
      const originalLen = item.pe.cleaned.length;
      if (translated.length < 3 && originalLen > 20) {
        console.warn(`Skipping suspiciously short translation "${translated}" for ${item.entry.key} (original: ${originalLen} chars)`);
        continue;
      }
      if (originalLen > 30 && translated.length < originalLen * 0.15) {
        console.warn(`Translation ratio too low for ${item.entry.key}: ${translated.length}/${originalLen} chars`);
        continue;
      }

      translated = normalizeTagPlaceholders(translated);

      // Unlock term placeholders → Arabic
      if (item.termLocks.locks.length > 0) {
        translated = unlockTerms(translated, item.termLocks.locks);
      }
      // Post-validation: re-insert any missing TAG_N placeholders
      const expectedTags = [...item.pe.tags.keys()];
      for (const tag of expectedTags) {
        if (!translated.includes(tag)) {
          console.warn(`Post-validation: re-inserting missing ${tag} for key ${item.entry.key}`);
          // Append missing tag at the end (safest fallback)
          translated = translated.trimEnd() + ' ' + tag;
        }
      }
      // Post-process: replace any remaining English glossary terms
      if (glossaryMap.size > 0) {
        translated = applyGlossaryPost(translated, glossaryMap);
      }
      result[item.entry.key] = restoreTags(translated, item.pe.tags);
    }
    return result;
  };

  if (effectiveKey) {
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${effectiveKey}`;
    const geminiResponse = await fetch(geminiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
        systemInstruction: { parts: [{ text: 'You are a Xenoblade Chronicles 3 game text translator. Output only valid JSON arrays. Never modify ⟪T#⟫ placeholders. ALWAYS use glossary terms exactly. ALWAYS maintain consistency with previously translated texts — same English word = same Arabic translation.' }] },
        generationConfig: { temperature: 0.3 },
      }),
    });

    if (!geminiResponse.ok) {
      const errText = await geminiResponse.text();
      console.error('Gemini API error:', errText);
      if (geminiResponse.status === 429) {
        console.log('Gemini quota exceeded, falling back to Lovable AI...');
      } else {
        if (geminiResponse.status === 400) throw new Error('مفتاح API غير صالح — تحقق من المفتاح');
        if (geminiResponse.status === 403) throw new Error('مفتاح API محظور أو منتهي — أنشئ مفتاحاً جديداً من Google AI Studio');
        throw new Error(`خطأ Gemini: ${geminiResponse.status}`);
      }
    } else {
      const geminiData = await geminiResponse.json();
      const content = geminiData.candidates?.[0]?.content?.parts?.[0]?.text || '';
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      if (!jsonMatch) throw new Error('فشل في تحليل استجابة Gemini');
      const sanitized = jsonMatch[0].replace(/[\x00-\x1F\x7F]/g, ' ');
      const translations: string[] = JSON.parse(sanitized);
      const aiResult = parseAndUnlock(translations);
      return { translations: { ...directResult, ...aiResult }, glossaryStats: stats };
    }
  }

  // Fallback to Lovable AI
  {
    const apiKey = Deno.env.get('LOVABLE_API_KEY');
    if (!apiKey) throw new Error('Missing LOVABLE_API_KEY');

    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          { role: 'system', content: 'You are a Xenoblade Chronicles 3 game text translator. Output only valid JSON arrays. Never modify ⟪T#⟫ placeholders. ALWAYS use glossary terms exactly. ALWAYS maintain consistency with previously translated texts — same English word = same Arabic translation.' },
          { role: 'user', content: prompt },
        ],
        temperature: 0.3,
      }),
    });

    if (!response.ok) {
      const err = await response.text();
      console.error('AI gateway error:', err);
      if (response.status === 402) throw new Error('انتهت نقاط الذكاء الاصطناعي — استخدم مفتاح Gemini الشخصي');
      if (response.status === 429) throw new Error('تم تجاوز حد الطلبات، حاول لاحقاً');
      throw new Error(`AI error: ${response.status}`);
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content || '';
    const jsonMatch = content.match(/\[[\s\S]*\]/);
    if (!jsonMatch) throw new Error('Failed to parse AI response');
    const sanitized = jsonMatch[0].replace(/[\x00-\x1F\x7F]/g, ' ');
    const translations: string[] = JSON.parse(sanitized);
    const aiResult = parseAndUnlock(translations);
    return { translations: { ...directResult, ...aiResult }, glossaryStats: stats };
  }
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { entries, glossary, context, userApiKey, provider, myMemoryEmail } = await req.json() as {
      entries: { key: string; original: string }[];
      glossary?: string;
      context?: { key: string; original: string; translation?: string }[];
      userApiKey?: string;
      provider?: string;
      myMemoryEmail?: string;
    };

    if (!entries || entries.length === 0) {
      return new Response(JSON.stringify({ error: 'لا توجد نصوص للترجمة' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const protectedEntries = entries.map(e => {
      const { cleaned, tags } = protectTags(e.original);
      return { ...e, cleaned, tags };
    });

    if (provider === 'mymemory') {
      const glossaryMap = glossary ? parseGlossaryToMap(glossary) : undefined;
      const { translations, charsUsed, glossaryStats } = await translateWithMyMemory(entries, protectedEntries, glossaryMap, myMemoryEmail);
      return new Response(JSON.stringify({ translations, charsUsed, glossaryStats }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    } else if (provider === 'google') {
      const glossaryMap = glossary ? parseGlossaryToMap(glossary) : undefined;
      const { translations, charsUsed, glossaryStats } = await translateWithGoogle(entries, protectedEntries, glossaryMap);
      return new Response(JSON.stringify({ translations, charsUsed, glossaryStats }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    } else {
      const { translations, glossaryStats } = await translateWithAI(entries, protectedEntries, glossary, context, userApiKey);
      return new Response(JSON.stringify({ translations, glossaryStats }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
  } catch (error) {
    console.error('Error:', error);
    return new Response(
      JSON.stringify({ error: error instanceof Error ? error.message : 'خطأ غير متوقع' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
